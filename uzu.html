
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Stylish GPU Particle</title>
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@500&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Quicksand', sans-serif;
    }

    canvas {
      display: block;
    }

    #start-button {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 18px 48px;
      font-size: 18px;
      font-weight: 600;
      color: #333;
      background-color: #ffffff;
      border: none;
      border-radius: 50px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 100;
    }

    #start-button:hover {
      background-color: #f0f0f0;
      transform: translate(-50%, -50%) scale(1.05);
    }

    #blendshape-scores {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      font-family: monospace;
      font-size: 12px;
      padding: 10px;
      max-height: 90vh;
      overflow-y: auto;
      white-space: pre;
      z-index: 20;
    }

    #expression-scores {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      font-family: monospace;
      font-size: 12px;
      padding: 10px;
      max-height: 90vh;
      overflow-y: auto;
      white-space: pre;
      z-index: 30;
    }

    #overlay {
      position: absolute;
      bottom: 10px;
      right: 10px;
      border: 2px solid white;
      z-index: 10;
    }
  </style>
  <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.152.2/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <video id="webcam" autoplay muted playsinline style="display:none;"></video>
  <canvas id="overlay" width="320" height="240"></canvas>
  <div id="blendshape-scores"></div>
  <button id="start-button">â–¶ Start</button>
  <div id="expression-scores"></div>


    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';
        import vision from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        const { FaceLandmarker, FilesetResolver } = vision;

        // particle æ±ºã‚
        const WIDTH = 128; //area
        //const PARTICLES = WIDTH * WIDTH;

        const mean = 10;
        const variance = 30;
        const PARTICLES = Math.floor(mean + Math.random() * variance * WIDTH * WIDTH); // ã“ã“ã«ã€ç¬ãã®æ¤œå‡ºã§å¢—ãˆã‚‹ã¨ã‹


        // åˆæœŸè¨­å®š
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = false;

        //ãƒ“ãƒ‡ã‚ª
        const video = document.getElementById("webcam");
        let faceLandmarker;
        let lastVideoTime = -1;

        // å³ä¸‹ã®ã‚«ãƒ¡ãƒ©å‹•ç”»
        const overlay = document.getElementById("overlay");
        const overlayCtx = overlay.getContext("2d");

        // ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ã§ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®å®Ÿè¡Œã®ãŸã‚ã®ãƒ•ãƒ©ã‚°
        let isDetectionActive = false; 


        // Startãƒœã‚¿ãƒ³
        document.getElementById("start-button").addEventListener("click", async () => {
            document.getElementById("start-button").style.display = "none";  // ãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤º
            await initFaceLandmarker();  // MediaPipeåˆæœŸåŒ–
            await startCamera();         // ã‚«ãƒ¡ãƒ©èµ·å‹• & ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
            isDetectionActive = true;    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æœ‰åŠ¹åŒ–
        });


        //camera.position.z = 10;
        camera.position.z = 5;

        // Resize handler
        window.addEventListener('resize', () => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
        });


        // ãƒ˜ãƒ«ãƒ‘ãƒ¼
        {
        const axesHelper = new THREE.AxesHelper(70);
        scene.add(axesHelper);
        // x èµ¤
        axesHelper.geometry.attributes.color.array.set([1, 0, 0], 0);
        axesHelper.geometry.attributes.color.array.set([1, 0, 0], 3);
        // y ç·‘
        axesHelper.geometry.attributes.color.array.set([0, 1, 0], 6);
        axesHelper.geometry.attributes.color.array.set([0, 1, 0], 9);
        // Z é’
        axesHelper.geometry.attributes.color.array.set([0, 0, 1], 12);
        axesHelper.geometry.attributes.color.array.set([0, 0, 1], 15);

        axesHelper.geometry.attributes.color.needsUpdate = true;
        }

        // mediapipeåˆæœŸåŒ–
        async function initFaceLandmarker() {
        const resolver = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
        );
        faceLandmarker = await FaceLandmarker.createFromOptions(resolver, {
            baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
            delegate: "GPU",
            },
            runningMode: "VIDEO",
            numFaces: 1,
            outputFaceBlendshapes: true  // ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—
        });
        }



        // GPU Compute
        const gpuCompute = new GPUComputationRenderer(WIDTH, WIDTH, renderer);
        const dtPosition = gpuCompute.createTexture();
        const dtVelocity = gpuCompute.createTexture();

        // åˆæœŸã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ä½ç½®ãƒ»é€Ÿåº¦
        const posArray = dtPosition.image.data;
        const velArray = dtVelocity.image.data;
        for (let i = 0; i < posArray.length; i += 4) {
            const radius = Math.cbrt(Math.random()) * 5;
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            posArray[i] = radius * Math.sin(phi) * Math.cos(theta); // x
            posArray[i + 1] = radius * Math.sin(phi) * Math.sin(theta); // y
            posArray[i + 2] = radius * Math.cos(phi); // z
            posArray[i + 3] = 1; // Î±

            velArray[i] = 0; // x
            velArray[i + 1] = 0; // y
            velArray[i + 2] = 0; // z
            velArray[i + 3] = 1; // Î±
        }

        const velocityVar = gpuCompute.addVariable("textureVelocity", `
            uniform float smileStrength;
            uniform float surpriseStrength;
            uniform float time;

            void main() {
                vec2 uv = gl_FragCoord.xy / resolution.xy;
                vec4 pos = texture2D(texturePosition, uv);
                vec4 vel = texture2D(textureVelocity, uv);

                vec3 tangent;
                vec3 gravity;
                

                /*if (smileStrength > surpriseStrength) {
                    tangent = normalize(vec3(-pos.y, pos.x, 0.0)); // åæ™‚è¨ˆå›ã‚Š
                    gravity = vec3(0.0, 0.0, 0.02); // ä¸Šæ˜‡
                } else {
                    tangent = normalize(vec3(pos.y, -pos.x, 0.0)); // æ™‚è¨ˆå›ã‚Š
                    gravity = vec3(0.0, 0.0, -0.02); // å¸ã„è¾¼ã¿
                }*/

                if (smileStrength > 0.1 && smileStrength + 0.05 > surpriseStrength) {
                    tangent = normalize(vec3(-pos.y, pos.x, 0.0)); // åæ™‚è¨ˆå›ã‚Š
                    gravity = vec3(0.0, 0.0, 0.02);                // ä¸Šæ˜‡
                } else {
                    tangent = normalize(vec3(pos.y, -pos.x, 0.0)); // æ™‚è¨ˆå›ã‚Š
                    gravity = vec3(0.0, 0.0, -0.02);               // å¸ã„è¾¼ã¿
                }


                vec3 acc = tangent * 0.01 + gravity;
                gl_FragColor = vec4((vel.xyz + acc) * 0.98, 1.0);

            }
        `, dtVelocity);

        const positionVar = gpuCompute.addVariable("texturePosition", `
            uniform float time;
            uniform vec3 eyeCenterPosition; // çœ¼ã®ä¸­å¿ƒä½ç½®ã‚’å—ã‘å–ã‚‹

            void main() {
                vec2 uv = gl_FragCoord.xy / resolution.xy;
                vec4 pos = texture2D(texturePosition, uv);
                vec4 vel = texture2D(textureVelocity, uv);

                // ç¾åœ¨ä½ç½®ã«é€Ÿåº¦ã‚’åŠ ç®—
                pos.xyz += vel.xyz * 0.007; //ã“ã®å€¤ã‚’å¤‰ãˆã‚‹ã¨ã€é€Ÿåº¦ãŒé…ããªã‚‹

                // yåº§æ¨™ãŒä½ã™ãã‚‹å ´åˆã€å†é…ç½®
                if (pos.z > 5.0 || pos.z < -5.0) {
                    float seed1 = dot(uv + time * 0.1, vec2(12.9898, 78.233));
                    float seed2 = dot(uv + time * 0.15, vec2(39.3468, 11.135));
                    float seed3 = dot(uv + time * 0.22, vec2(93.843, 15.315));

                    float rnd1 = fract(sin(seed1) * 43758.5453);
                    float rnd2 = fract(sin(seed2) * 23421.6311);
                    float rnd3 = fract(sin(seed3) * 12521.1353);

                    // çƒçŠ¶é…ç½®ã«å¤‰æ›
                    float r = pow(rnd1, 1.0/3.0) * 5.0;
                    float theta = rnd2 * 6.28318;
                    float phi = acos(2.0 * rnd3 - 1.0);

                    //pos.x = r * sin(phi) * cos(theta);
                    //pos.y = r * sin(phi) * sin(theta);
                    //pos.z = r * cos(phi);

                    // çœ¼ã®ä½ç½®ã‚’ä¸­å¿ƒã«é…ç½®
                    pos.x = eyeCenterPosition.x + r * sin(phi) * cos(theta);
                    pos.y = eyeCenterPosition.y + r * sin(phi) * sin(theta);
                    pos.z = max(eyeCenterPosition.z+ r * cos(phi), -2.0);
                }
                gl_FragColor = pos;
            }
        `, dtPosition);

        


        velocityVar.dependencies = [positionVar, velocityVar];
        positionVar.dependencies = [positionVar, velocityVar];






        const error = gpuCompute.init();
        if (error !== null) {
        console.error(error);
        }

        // ğŸ‘‡ ã“ã“ã«è¿½åŠ ã™ã‚‹ï¼ï¼
        positionVar.material.uniforms.eyeCenterPosition = { value: new THREE.Vector3(0, 0, 0) };
        velocityVar.material.uniforms.smileStrength = { value: 0.0 };
        velocityVar.material.uniforms.surpriseStrength = { value: 0.0 };


        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¸ã‚ªãƒ¡ãƒˆãƒª
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLES * 3);
        const uvs = new Float32Array(PARTICLES * 2);
        let p = 0, u = 0;
        for (let i = 0; i < WIDTH; i++) {
            for (let j = 0; j < WIDTH; j++) {
                positions[p++] = 0;
                positions[p++] = 0;
                positions[p++] = 0;
                uvs[u++] = i / (WIDTH - 1);
                uvs[u++] = j / (WIDTH - 1);
            }
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

        // ãƒãƒ†ãƒªã‚¢ãƒ«
        const material = new THREE.ShaderMaterial({
        uniforms: {
            texturePosition: { value: null },
            pointSize: { value: 2.0 },
            time: { value: 0 },
            blinkStrength: {value: 0.0},
            smileStrength: { value: 0.0 }, // ç¬‘é¡”ã®å¼·ã•ã‚’å—ã‘å–ã‚‹
            surpriseStrength: { value: 0.0 }, // é©šãã®å¼·ã•ã‚’å—ã‘å–ã‚‹

        },
        vertexShader: `
            uniform sampler2D texturePosition;
            uniform float pointSize;

            void main() {
                vec4 pos = texture2D(texturePosition, uv);
                gl_Position = projectionMatrix * modelViewMatrix * pos;
                gl_PointSize = pointSize;
            }
        `,
        fragmentShader: `
            uniform float blinkStrength;
            uniform float smileStrength; // ç¬‘é¡”ã®å¼·ã•ã‚’å—ã‘å–ã‚‹
            uniform float surpriseStrength; // é©šãã®å¼·ã•ã‚’å—ã‘å–ã‚‹
            uniform float time;
            
            void main() {
                vec2 coord = gl_PointCoord - 0.5;
                if (length(coord) > 0.5) discard;

                // åŸºæœ¬è‰²ï¼ˆç™½ï¼‰
                vec3 baseColor = vec3(1.0);

                // ç¬ãã§èµ¤å‘³ã‚’åŠ ãˆã‚‹
                baseColor = mix(baseColor, vec3(1.0, 0.0, 0.0), blinkStrength);

                // ç¬‘é¡”ã§é»„è‰²å‘³ï¼ˆã¾ãŸã¯æ˜ã‚‹ã•ï¼‰ã‚’åŠ ãˆã‚‹
                baseColor = mix(baseColor, vec3(1.0, 1.0, 0.0), smileStrength);

                // é©šã â†’ ç™ºå…‰ï¼ˆé’ç™½ï¼‹ãƒ‘ãƒ«ã‚¹ï¼‰
                float flash = sin(time * 10.0) * 0.5 + 0.5; // ãƒ‘ãƒ«ã‚¹: 0ã€œ1
                vec3 glowColor = vec3(0.8, 0.9, 1.0); // é’ç™½è‰²
                baseColor = mix(baseColor, glowColor, surpriseStrength);

                // å¹³å‡ã¨ã‹ä½¿ç”¨ã—ã¦ã€å„ã‚¹ã‚³ã‚¢ã«å¯¾ã—ã¦ã®è‰²ã‚’å¤‰åŒ–ã•ã›ã‚‹

                // æœ€çµ‚çš„ãªè‰²ã‚’åˆ¶é™ï¼ˆç™½ã‚’è¶…ãˆãªã„ã‚ˆã†ã«ï¼‰
                baseColor = clamp(baseColor, 0.0, 1.0);

                //gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
                gl_FragColor = vec4(baseColor, 1.0);
            }
        `,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

              // MediaPipeã®é¡”æ¤œå‡º
            if (isDetectionActive && faceLandmarker && video.readyState >= 2) {
                const now = performance.now();
                if (video.currentTime !== lastVideoTime) {
                    lastVideoTime = video.currentTime;
                    const results = faceLandmarker.detectForVideo(video, now);

                    // ğŸ”½ è¡¨ç¤ºã‚¨ãƒªã‚¢ã‚’å–å¾—
                    const scoreDiv = document.getElementById("blendshape-scores");
                    // ğŸ”½ ã‚¹ã‚³ã‚¢ã‚’è¡¨ç¤º
                    const expressionScores = document.getElementById("expression-scores");

                    // ğŸ‘‡ overlay æç”»ãƒªã‚»ãƒƒãƒˆ ï¼ˆã‚«ãƒ¡ãƒ©å‹•ç”»ç¢ºèªï¼‰
                    overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
                    overlayCtx.drawImage(video, 0, 0, overlay.width, overlay.height);

                    //console.log("ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯æ•°:", results.faceLandmarks[0].length);

                    // çœ¼ã®ä½ç½®ã§ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’æ“ä½œ
                    const leftEye = results.faceLandmarks[0][468]; // å·¦ç›®ã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯
                    const rightEye = results.faceLandmarks[0][473]; // å³ç›®ã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯
                    const eyeLeftPosition = new THREE.Vector3(leftEye.x - 0.5, -(leftEye.y - 0.5), - 0.5, -(leftEye.z - 0.5)); // leftEye.z - 0.1
                    const eyeRightPosition = new THREE.Vector3(rightEye.x - 0.5, -(rightEye.y - 0.5), -(rightEye.z - 0.5)); // rightEye.z - 0.1
                    // ä¸­å¿ƒä½ç½®ï¼ˆä¸¡ç›®ã®ä¸­é–“ï¼‰
                    const eyeCenterPos = new THREE.Vector3().addVectors(eyeLeftPosition, eyeRightPosition).multiplyScalar(0.5);
                    positionVar.material.uniforms.eyeCenterPosition.value.copy(eyeCenterPos);
                    //console.log("eyeCenterPosition:", eyeCenterPos);



                    if (results.faceLandmarks?.length > 0) {
                        
                        // ğŸ”½ ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ã‚¹ã‚³ã‚¢ã‚’å–å¾—ã—ã¦è¡¨ç¤º
                        const blendshapes = results.faceBlendshapes[0].categories;
                        const lines = blendshapes.map(bs =>
                            `${bs.categoryName.padEnd(20)}: ${bs.score.toFixed(3)}`
                        );
                        scoreDiv.textContent = lines.join("\n");

                        // ç¬ãğŸ”½å„ã‚¹ã‚³ã‚¢ã«å¯¾ã™ã‚‹å€¤ã®å–å¾—ã¨å€¤ã®è¨ˆç®—
                        const blinkLeft = blendshapes.find(bs => bs.categoryName === "eyeBlinkLeft")?.score || 0;
                        const blinkRight = blendshapes.find(bs => bs.categoryName === "eyeBlinkRight")?.score || 0;
                        const blinkStrength = (blinkLeft + blinkRight) / 2;
                        material.uniforms.blinkStrength.value = blinkStrength;

                        // ç¬‘é¡”ã®æ™‚
                        const smileLeft = blendshapes.find(bs => bs.categoryName === "mouthSmileLeft")?.score || 0;
                        const smileRight = blendshapes.find(bs => bs.categoryName === "mouthSmileRight")?.score || 0;
                        const smileStrength = (smileLeft + smileRight) / 2;
                        
                        // é©šã
                        const eyeWideLeft = blendshapes.find(bs => bs.categoryName === "eyeWideLeft")?.score || 0;
                        const eyeWideRight = blendshapes.find(bs => bs.categoryName === "eyeWideRight")?.score || 0;
                        const jawOpen = blendshapes.find(bs => bs.categoryName === "jawOpen")?.score || 0;
                        const surpriseStrength = Math.min((eyeWideLeft*70 + eyeWideRight*70 + jawOpen) / 3, 1.0);
                        
                        // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã® uniform ã«æ¸¡ã™
                        material.uniforms.smileStrength.value = smileStrength;
                        material.uniforms.surpriseStrength.value = surpriseStrength;

                        velocityVar.material.uniforms.smileStrength.value = smileStrength;
                        velocityVar.material.uniforms.surpriseStrength.value = surpriseStrength;

                        // ã“ã“ã§å€¤ã‚’è¡¨ç¤º
                        document.getElementById("expression-scores").textContent =
                        `smileStrength: ${smileStrength.toFixed(3)}\nsurpriseStrength: ${surpriseStrength.toFixed(3)}`;


                        // ğŸ‘‡ ç¢ºèªç”»é¢ã§ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯æç”»
                        overlayCtx.fillStyle = 'red';
                        for (const pt of results.faceLandmarks[0]) {
                            overlayCtx.beginPath();
                            overlayCtx.arc(pt.x * overlay.width, pt.y * overlay.height, 2, 0, 2 * Math.PI);
                            overlayCtx.fill();
                        }

                        // ç‰¹å®šç•ªå·ã ã‘è‰²ã‚’å¤‰ãˆã‚‹ï¼ˆ33ç•ªã‚’é’ã§å¼·èª¿ï¼‰
                        /*const specialPt = results.faceLandmarks[0][473];
                        overlayCtx.fillStyle = 'cyan';
                        overlayCtx.beginPath();
                        overlayCtx.arc(specialPt.x * overlay.width, specialPt.y * overlay.height, 4, 0, 2 * Math.PI);
                        overlayCtx.fill();*/
                        
                    }

                }
            }

            gpuCompute.compute();

            material.uniforms.texturePosition.value = gpuCompute.getCurrentRenderTarget(positionVar).texture;
            material.uniforms.time.value = performance.now() * 0.001;

            renderer.setRenderTarget(null);
            renderer.render(scene, camera);
        }


        // mediapipeèµ·å‹•
        async function startCamera() {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            await video.play();
            animate(); // GPUãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æç”»ã‚‚å«ã‚ã¦ã“ã“ã‹ã‚‰é–‹å§‹
        }
        // ğŸ‘‡ ãƒœã‚¿ãƒ³ã®å½±éŸ¿ã§æ¶ˆãˆã¾ã—ãŸ
        //await initFaceLandmarker();
        //await startCamera();

        animate();

    </script>
</body>
</html>